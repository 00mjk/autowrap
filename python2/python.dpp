/**
   Make D symbiks out of  Python macros and helper functions
 */
#include "Python.h"



// All of the cases are macros instead of values in an enum
enum MethodArgs {
    Var = METH_VARARGS,
    Keywords = METH_KEYWORDS,
    None = METH_NOARGS,
    O = METH_O,
}

// Demacroify
alias ModuleInitRet = PyMODINIT_FUNC;


/**
   Create a Python module.
   The strings are compile-time parameters to avoid passing GC-allocated memory
   to Python (by calling std.string.toStringz or manually appending the null
   terminator).
 */
auto createModule(string name, string doc = "", long size = -1)(PyMethodDef[] methods) {
    assert(methods[$-1] == PyMethodDef.init, "Methods array must end with a sentinel");
    static PyModuleDef moduleDef;
    moduleDef = pyModuleDef(name.ptr, doc.ptr, size, &methods[0]);
    return PyModule_Create(&moduleDef);
}

/**
   Helper function to get around the C syntax problem with
   PyModuleDef_HEAD_INIT - it doesn't compile in D.
 */
private auto pyModuleDef(A...)(auto ref A args) {
    import std.functional: forward;

    return PyModuleDef(
        // the line below is a manual PyModuleDef_HEAD_INIT
        PyModuleDef_Base(PyObject(1 /*ref count*/, null /*type*/), null /*m_init*/, 0/*m_index*/, null/*m_copy*/),
        forward!args
    );
}

/**
   Helper function to create PyMethodDef structs.
   The strings are compile-time parameters to avoid passing GC-allocated memory
   to Python (by calling std.string.toStringz or manually appending the null
   terminator).
 */
auto pyMethodDef(string name, int flags = MethodArgs.Var, string doc = "")(PyCFunction cfunction) pure {
    return PyMethodDef(name.ptr, cfunction, flags, doc.ptr);
}


auto pyMethodSentinel() {
    return PyMethodDef();
}
