/**
   Functions to wrap entities in D modules for Python consumption.

   These functions are usually not called directly, but from the mixin generated by
   autowrap.python.boilerplate.pydBoilerplate.
 */
module autowrap.python.wrap;

import autowrap.reflection: isUserAggregate, isModule;
import std.meta: allSatisfy;
import std.traits: isArray;


private alias I(alias T) = T;
private enum isString(alias T) = is(typeof(T) == string);

///  Wrap global functions from multiple modules
void wrapAllFunctions(Modules...)() if(allSatisfy!(isModule, Modules)) {
    import autowrap.reflection: AllFunctions;
    import pyd.pyd: def, PyName;

    static foreach(function_; AllFunctions!Modules)
    {
        static if(__traits(compiles,def!(function_.symbol,PyName!(toSnakeCase(function_.name)))()))
	{
		//pragma(msg,"+ " ~ function_.name);
		def!(function_.symbol, PyName!(toSnakeCase(function_.name)))();
	}
	else
		pragma(msg,"- " ~ function_.name);
    }
}


/// Converts an identifier from camelCase or PascalCase to snake_case.
string toSnakeCase(in string str) @safe pure {

    import std.algorithm: all, map;
    import std.ascii: isUpper;

    if(str.all!isUpper) return str;

    string ret;

    string convert(in size_t index, in char c) {
        import std.ascii: isLower, toLower;

        const prefix = index == 0 ? "" : "_";
        const isHump =
            (index == 0 && c.isUpper) ||
            (index > 0 && c.isUpper && str[index - 1].isLower);

        return isHump ? prefix ~ c.toLower : "" ~ c;
    }

    foreach(i, c; str) {
        ret ~= convert(i, c);
    }

    return ret;
}


@("toSnakeCase empty")
@safe pure unittest {
    static assert("".toSnakeCase == "");
}

@("toSnakeCase no caps")
@safe pure unittest {
    static assert("foo".toSnakeCase == "foo");
}

@("toSnakeCase camelCase")
@safe pure unittest {
    static assert("toSnakeCase".toSnakeCase == "to_snake_case");
}

@("toSnakeCase PascalCase")
@safe pure unittest {
    static assert("PascalCase".toSnakeCase == "pascal_case");
}

@("toSnakeCase ALLCAPS")
@safe pure unittest {
    static assert("ALLCAPS".toSnakeCase == "ALLCAPS");
}


/**
   wrap all aggregates found in the given modules, specified by their name
   (to avoid importing all of them first).

   This function wraps all struct and class definitions, and also all struct and class
   types that are parameters or return types of any functions found.
 */
void wrapAllAggregates(Modules...)() if(allSatisfy!(isModule, Modules)) {

    import autowrap.reflection: AllAggregates, Module;
    import std.meta: staticMap;
    import std.traits: fullyQualifiedName,Unqual;
	import symmetry.integration.common;
	import symmetry.integration.dcpp;
	import symmetry.generative;

    static foreach(aggregate; AllAggregates!Modules) {
        static if(__traits(compiles, wrapAggregate!aggregate))
	{
            //pragma(msg, "+ " ~ fullyQualifiedName!aggregate);
            //wrapAggregate!(Unqual!aggregate);
            wrapAggregate!(aggregate);
	}
        else {
            //wrapAggregate!aggregate; // uncomment to see the error messages from the compiler
            pragma(msg, "- " ~ fullyQualifiedName!aggregate);
            //wrapAggregate!aggregate; // uncomment to see the error messages from the compiler
        }
    }
}

/**
   Wrap aggregate of type T.
 */
auto wrapAggregate(T)() if(isUserAggregate!T) {
    import autowrap.reflection: Symbol;
    import autowrap.python.pyd.class_wrap: MemberFunction,validMemberFunction;
    import pyd.pyd: wrap_class, Member, Init;
    import std.meta: staticMap, Filter, AliasSeq;
    import std.traits: Parameters, FieldNameTuple, hasMember,isCopyable;
    import std.typecons: Tuple;

    //pragma(msg,"wrapping " ~T.stringof);
    alias AggMember(string memberName) = Symbol!(T, memberName);
    alias members = staticMap!(AggMember, __traits(allMembers, T));

    alias memberFunctions = Filter!(isMemberFunction, members);

    static if(hasMember!(T, "__ctor"))
        alias constructors = AliasSeq!(__traits(getOverloads, T, "__ctor"));
    else
        alias constructors = AliasSeq!();

    // If we staticMap with std.traits.Parameters, we end up with a collapsed tuple
    // i.e. with one constructor that takes int and another that takes int, string,
    // we'd end up with 3 elements (int, int, string) instead of 2 ((int), (int, string))
    // so we package them up in a std.typecons.Tuple to avoid flattening
    // each being an AliasSeq of types for the constructor
    alias ParametersTuple(alias F) = Tuple!(Parameters!F);

    // A tuple, with as many elements as constructors. Each element is a
    // std.typecons.Tuple of the constructor parameter types.
    alias constructorParamTuples = staticMap!(ParametersTuple, constructors);

    // Apply pyd's Init to the unpacked types of the parameter Tuple.
    alias InitTuple(alias Tuple) = Init!(Tuple.Types);

    enum isPublic(string fieldName) =isPublicSymbol!(T,fieldName);
    alias publicFields = Filter!(isPublic, FieldNameTuple!T);

    template validF(A...)
    {
	    import std.string:startsWith;
	    enum notOpAssign = !(__traits(identifier,A[0]).startsWith("opAssign"));
	   static if (!isCopyable!T)
		   enum validF= validMemberFunction!(T,A);
		   //enum validF= notOpAssign && validMemberFunction!(T,A);
	   else
		   enum validF= validMemberFunction!(T,A);
    }
    alias validMemberFunctions = Filter!(validF,memberFunctions);
    wrap_class!(
        T,
        staticMap!(Member, publicFields),
        staticMap!(MemberFunction,validMemberFunctions),
        staticMap!(InitTuple, constructorParamTuples),
   );
}



// must be a global template
private template isMemberFunction(A...) if(A.length == 1) {
    alias T = A[0];
    static if (__traits(compiles,isPublicFunction!T && !isInternalField!T))
	    enum isMemberFunction = isPublicFunction!T && !isInternalField!T;
    else
	    enum isMemberFunction = false;
}

private template isInternalFieldHelper(string fieldName)
{
	import std.string:startsWith;
	import std.algorithm:any;
	import std.meta:AliasSeq;
	enum isInternalFieldHelper = any!(field=>fieldName.startsWith(field))(["__ctor","__field","__aggr","__postblit","__dtor"]);
}

private template isInternalField(alias T)
{
	import std.string:startsWith;
	import std.algorithm:any;
	import std.meta:AliasSeq;
	static if(__traits(compiles, __traits(identifier, T)))
	{
		enum field = __traits(identifier,T);
		enum isInternalField = isInternalFieldHelper!field;
	}
	else
	{
		enum isInternalField = false;
	}
}


private template isPublicSymbol(alias T, string fieldName)
{
	static if (__traits(compiles,isPublicSymbol!( __traits(getMember, T, fieldName))))
		enum isPublicSymbol = isPublicSymbol!(__traits(getMember,T,fieldName));
	else
		enum isPublicSymbol = false;
}

private template isPublicFunction(alias F) {
    import std.traits: isFunction;
    enum isPublicFunction = isPublicSymbol!F && isFunction!F;
}

private template isPublicSymbol(alias S) {
    static if (__traits(compiles,__traits(getProtection,S)))
    {
	    enum prot = __traits(getProtection, S);
	    enum isPublicSymbol =  (prot == "export" || prot == "public");
    }
    else
	    emum isPublicSymbol = false;
}
