from contextlib import contextmanager


class Writer:
    def __init__(self, out_file):
        self.out_file = out_file
        self.indent_level = 0

    def write(self, val):
        self.out_file.write(f"{val}")

    def writeln(self, line):
        self.indent()
        self.write(f"{line}\n")

    def indent(self):
        self.write(f"{self.indent_level * 4 * ' '}")

    def open_block(self):
        self.writeln("{")
        self.indent_level += 1

    def close_block(self):
        self.indent_level -= 1
        self.writeln("}")


@contextmanager
def NamedBlock(writer, attr, line):
    try:
        writer.writeln(attr)
        writer.writeln(line)
        writer.open_block()
        yield writer
    finally:
        writer.close_block()


def translate(source_code, filename):
    from python_to_ir import transform

    tests = transform(source_code)

    with open(filename, "w") as file:
        writer = Writer(file)

        writer.writeln("// this file is autogenerated, do not modify by hand")

        with NamedBlock(writer,
                        "",
                        f"namespace Autowrap.CSharp.Tests") as block:
            _write_imports(block, tests)

            # we use the fully-qualified names to avoid name-collisions
            # with the symbols from the test
            with NamedBlock(
                    block,
                    "[Microsoft.VisualStudio.TestTools.UnitTesting.TestClass]",
                    "public class TestMain"
            ) as block:

                for test in tests:
                    _translate_test(block, test)


def _write_imports(writer, tests):
    from ir import Import

    def imports_in_test(test):
        return [s.module for s in test.statements if isinstance(s, Import)]

    nested_imports = [imports_in_test(test) for test in tests]
    flat_imports = [i for sublist in nested_imports for i in sublist]
    unique_imports = sorted(set(flat_imports))
    # Filter datetime out of the Python tests
    imports = [i for i in unique_imports if i != "datetime"]

    for import_ in imports:
        writer.writeln(f"using {import_.capitalize()};")

    writer.writeln('using Microsoft.VisualStudio.TestTools.UnitTesting;')

    writer.writeln("")


def _translate_test(writer, test):

    with NamedBlock(
        writer,
        "[Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod]",
        f"public void {test.name}()"
    ) as block:

        context = Context()
        for statement in test.statements:
            translation = _translate(context, statement)
            if translation != "":
                block.writeln(f"{translation};")


class Context:
    def __init__(self):
        self._variables = set()

    def has_variable(self, var):
        return var in self._variables

    def add_variable(self, var):
        self._variables.add(var)


def _to_csharp_case(name):
    parts = name.split('_')
    ret = ''.join(x.capitalize() for x in parts)
    # hacky but works
    return 'ToString' if ret == 'Tostring' else ret


def _translate(context, node):
    import sys

    this_module = sys.modules[__name__]
    node_type = type(node).__name__
    function_name = '_translate_' + node_type

    assert hasattr(this_module, function_name), \
        f"No C# handler for IR type {node_type}"

    return eval(f"{function_name}(context, node)")


def _translate_Assertion(context, assertion):
    actual = _translate(context, assertion.lhs)
    expected = _translate(context, assertion.rhs)
    if expected == '""':
        expected = 'null'
    return f"Assert.AreEqual({expected}, {actual})"


def _translate_int(context, val):
    return f"{val}"


def _translate_str(context, val):
    return f'{val}'


def _translate_Import(context, import_):
    # nothing to do here since imports from Python have to become top-level
    # using declarations in C#
    return ""


def _translate_Assignment(context, assignment):
    lhs = _translate(context, assignment.lhs)
    rhs = _translate(context, assignment.rhs)

    is_attr = '.' in lhs
    if not context.has_variable(lhs) and not is_attr:
        maybe_var = 'var '
    else:
        maybe_var = ''

    context.add_variable(lhs)

    return f"{maybe_var}{lhs} = {rhs}"


def _translate_FunctionCall(context, call):
    receiver = _translate(context, call.receiver)
    prologue = ""
    epilogue = ""
    # hacky way to determine if we need to new up a class
    if receiver[0].isupper():
        prologue = '(new '
        epilogue = ')'

    args = ", ".join([_translate(context, x) for x in call.args])

    return f"{prologue}{receiver}({args}){epilogue}"


def _translate_IfPython(context, ifpython):
    return "// TODO: ifpython"


def _translate_IfPyd(context, ifpyd):
    return f"// TODO: ifpyd {ifpyd}"


def _translate_IfPynih(context, ifpynih):
    return f"// TODO: ifpynih {ifpynih}"


def _translate_ShouldThrow(context, should_throw):
    return f"// TODO: ShouldThrow {should_throw}"


def _translate_Sequence(context, seq):
    return f"{{{seq}}}"


def _translate_NumLiteral(context, val):
    return f"{val.value}"


def _translate_BytesLiteral(context, val):
    return f"{val.value}"


def _translate_StringLiteral(context, val):
    return f'"{val.value}"'


def _translate_Attribute(context, val):
    instance = _translate(context, val.instance)
    attribute = _translate(context, val.attribute)
    return f"{instance}.{_to_csharp_case(attribute)}"
