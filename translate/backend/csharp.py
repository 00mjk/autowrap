class Writer:
    def __init__(self, out_file):
        self.out_file = out_file
        self.indent_level = 0

    def writeln(self, line):
        self.out_file.write(f"{self.indent_level * 4 * ' '}{line}\n")

    def open_block(self):
        self.writeln("{")
        self.indent_level += 1

    def close_block(self):
        self.indent_level -= 1
        self.writeln("}")


def translate(source_code, filename):
    from python_to_ir import transform

    tests = transform(source_code)

    with open(filename, "w") as file:
        writer = Writer(file)

        _write_header(writer, tests)

        # we use the fully-qualified names to avoid name-collisions
        # with the symbols from the test
        writer.writeln(
            "[Microsoft.VisualStudio.TestTools.UnitTesting.TestClass]")
        writer.writeln("public class TestMain")
        writer.open_block()

        for test in tests:
            _translate_test(writer, test)

        writer.close_block()


def _write_header(writer, tests):
    from ir import Import

    writer.writeln("// this file is autogenerated, do not modify by hand")
    writer.writeln("")
    writer.writeln('using Microsoft.VisualStudio.TestTools.UnitTesting;')

    def imports_in_test(test):
        return [s.module for s in test.statements if isinstance(s, Import)]

    nested_imports = [imports_in_test(test) for test in tests]
    flat_imports = [i for sublist in nested_imports for i in sublist]
    unique_imports = sorted(set(flat_imports))
    # Filter datetime out of the Python tests
    imports = [i for i in unique_imports if i != "datetime"]

    for import_ in imports:
        writer.writeln(f"using {import_.capitalize()};")

    writer.writeln("")


def _translate_test(writer, test):
    writer.writeln(
        f"[Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod]")
    writer.writeln(f"public void {test.name}()")
    writer.open_block()

    for statement in test.statements:
        statement_type = type(statement).__name__
        function_name = '_translate_' + statement_type
        eval(f"{function_name}(writer, statement)")

    writer.close_block()


def _translate_Assertion(writer, assertion):
    def stringify(value):
        """
            Transform value into a string
            """
        if isinstance(value, str):
            return '"' + value + '"'
        else:
            return str(value)

    actual = assertion.lhs
    expected = stringify(assertion.rhs)
    writer.writeln(
        f"// Assert.AreEqual({(expected)}, {actual});")


def _translate_Import(writer, import_):
    # nothing to do here since imports from Python have to become top-level
    # using declarations in C#
    pass
