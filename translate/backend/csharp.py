from contextlib import contextmanager


class Writer:
    def __init__(self, out_file):
        self.out_file = out_file
        self.indent_level = 0

    def write(self, val):
        self.out_file.write(f"{val}")

    def writeln(self, line):
        self.indent()
        self.write(f"{line}\n")

    def indent(self):
        self.write(f"{self.indent_level * 4 * ' '}")

    def open_block(self):
        self.writeln("{")
        self.indent_level += 1

    def close_block(self):
        self.indent_level -= 1
        self.writeln("}")


@contextmanager
def NamedBlock(writer, attr, line):
    try:
        writer.writeln(attr)
        writer.writeln(line)
        writer.open_block()
        yield writer
    finally:
        writer.close_block()


def translate(source_code, filename):
    from python_to_ir import transform

    tests = transform(source_code)

    with open(filename, "w") as file:
        writer = Writer(file)

        writer.writeln("// this file is autogenerated, do not modify by hand")

        with NamedBlock(writer,
                        "",
                        f"namespace Autowrap.CSharp.Tests") as block:
            _write_imports(block, tests)

            # we use the fully-qualified names to avoid name-collisions
            # with the symbols from the test
            with NamedBlock(
                    block,
                    "[Microsoft.VisualStudio.TestTools.UnitTesting.TestClass]",
                    "public class TestMain"
            ) as block:

                for test in tests:
                    _translate_test(block, test)


def _write_imports(writer, tests):
    from ir import Import

    def imports_in_test(test):
        return [s.module for s in test.statements if isinstance(s, Import)]

    nested_imports = [imports_in_test(test) for test in tests]
    flat_imports = [i for sublist in nested_imports for i in sublist]
    unique_imports = sorted(set(flat_imports))
    # Filter datetime out of the Python tests
    imports = [i for i in unique_imports if i != "datetime"]

    for import_ in imports:
        writer.writeln(f"using {import_.capitalize()};")

    writer.writeln('using Microsoft.VisualStudio.TestTools.UnitTesting;')
    writer.writeln('using System;')

    writer.writeln("")


def _translate_test(writer, test):

    with NamedBlock(
        writer,
        "[Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod]",
        f"public void {test.name}()"
    ) as block:

        context = Context()
        for statement in test.statements:
            translation = _translate(context, statement)
            if translation != "":
                block.writeln(f"{translation};")


class Context:
    def __init__(self):
        self._variables = set()
        self._func_to_module = dict()

    def add_variable(self, var):
        self._variables.add(var)

    def has_variable(self, var):
        return var in self._variables

    def add_import(self, import_):
        for importee in import_.importees:
            self._func_to_module[importee] = import_.module

    def find_namespace(self, function):
        """
        Finds the C# namespace a corresponding Python function called
        `function` is in
        """
        module = self._func_to_module[function]
        return f"{_to_csharp_case(module)}.Functions"


def _to_csharp_case(name):
    parts = name.split('_')
    ret = ''.join(x.capitalize() for x in parts)

    # very hacky
    if ret == 'Tostring':
        return 'ToString'
    elif ret == 'WrapAll':
        return 'Wrap_all'
    else:
        return ret


def _translate(context, node):
    import sys

    this_module = sys.modules[__name__]
    node_type = type(node).__name__
    function_name = '_translate_' + node_type

    assert hasattr(this_module, function_name), \
        f"No C# handler for IR type {node_type}"

    return eval(f"{function_name}(context, node)")


def _translate_Assertion(context, assertion):
    actual = _translate(context, assertion.lhs)
    expected = _translate(context, assertion.rhs)
    if expected == '""':
        expected = 'null'
    return f"Assert.AreEqual({expected}, {actual})"


def _translate_int(context, val):
    return f"{val}"


def _translate_str(context, val):
    return f'{val}'


def _translate_Import(context, import_):
    # we add to the current list of imports so that we can know which C#
    # namespace the Python free functions were put in
    context.add_import(import_)

    # nothing to return since imports from Python have to become top-level
    # using declarations in C#
    return ""


def _translate_Assignment(context, assignment):
    lhs = _translate(context, assignment.lhs)
    rhs = _translate(context, assignment.rhs)

    # if an attribute access, never declare a new variable
    is_attr = '.' in lhs
    if not context.has_variable(lhs) and not is_attr:
        maybe_var = 'var '
    else:
        maybe_var = ''

    context.add_variable(lhs)

    return f"{maybe_var}{lhs} = {rhs}"


def _translate_FunctionCall(context, call):
    receiver = _translate(context, call.receiver)
    prologue = ""
    epilogue = ""
    # hacky way to determine if we're calling a constructor
    is_ctor = receiver[0].isupper()
    # hacky way to determine if we're calling a method or function
    is_function = '.' not in receiver

    if is_ctor:
        # we add parens here because of expressions
        # e.g. `Foo(42).method(77)` gets translated as
        # `(new Foo(42)).method(77)`
        prologue = '(new '
        epilogue = ')'
    elif is_function:
        # special-case date:
        if receiver == 'date':
            receiver = 'new DateTime'
        else:
            # Functions are special since C# is strictly OOP, and
            # autowrap emits static methods inside
            # $(MODULE_NAME).Functions, so we have to find out how to
            # prefix the function call accordingly
            namespace = context.find_namespace(receiver)
            receiver = f"{namespace}.{_to_csharp_case(receiver)}"

    args = ", ".join([_translate(context, x) for x in call.args])

    return f"{prologue}{receiver}({args}){epilogue}"


def _translate_IfPython(context, ifpython):
    return "// TODO: ifpython"


def _translate_IfPyd(context, ifpyd):
    return f"// TODO: ifpyd {ifpyd}"


def _translate_IfPynih(context, ifpynih):
    return f"// TODO: ifpynih {ifpynih}"


def _translate_ShouldThrow(context, should_throw):
    return f"// TODO: ShouldThrow {should_throw}"


def _translate_Sequence(context, seq):
    return f"{{{seq}}}"


def _translate_NumLiteral(context, val):
    return f"{val.value}"


def _translate_BytesLiteral(context, val):
    return f"{val.value}"


def _translate_StringLiteral(context, val):
    return f'"{val.value}"'


def _translate_Attribute(context, val):
    instance = _translate(context, val.instance)
    attribute = _translate(context, val.attribute)
    return f"{instance}.{_to_csharp_case(attribute)}"


def _translate_Index(context, val):
    name = _translate(context, val.name)
    index = _translate(context, val.index)
    return f"{name}[{index}]"
